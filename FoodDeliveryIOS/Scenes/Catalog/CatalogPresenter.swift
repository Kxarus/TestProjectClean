//
//  CatalogPresenter.swift
//  TestProject
//
//  Created by Roman Kiruxin on 19.10.2022.
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit

protocol CatalogPresentationLogic {
    func presentData(response: Catalog.Model.Response.ResponseType)
}

final class CatalogPresenter {
    
    // MARK: - External vars
    weak var viewController: CatalogDisplayLogic?
}

// MARK: - Presentation logic
extension CatalogPresenter: CatalogPresentationLogic {
    
    func presentData(response: Catalog.Model.Response.ResponseType) {
        switch response {
        case .products(let response):
            presentProducts(response: response)
        case .sales(let response):
            presentSales(response: response)
//        case .productsRM(let response):
//            presentProductsRM(response: response)
//        case .salesRM(let response):
//            presentSalesRM(response: response)
        }
    }
}

// MARK: - Private methods

private extension CatalogPresenter {
    func presentProducts(response: CatalogResponse) {
        
        var categories: [CategoryModel] = []
        for data in response.data {
            
            guard let category = data.category else {
                return
            }
            
            var isFound = false
            let _ = categories.map({ (item) in
                
                if item.name == category {
                    isFound = true
                }
                
            })
            
            if isFound == false {
                let newCategory: CategoryModel?
                if categories.count == 0 {
                    newCategory = CategoryModel(name: category, isSelected: true)
                } else {
                    newCategory = CategoryModel(name: category, isSelected: false)
                }
                categories.append(newCategory!)
            }
        }
        
        viewController?.display(viewModel: .categories(categories))
        viewController?.display(viewModel: .products(response.data))
    }
    
//    func presentProductsRM(response: [ProductRM]) {
//        var categories: [CategoryModel] = []
//        for data in response {
//
//            let category = data.category
//
//            var isFound = false
//            let _ = categories.map({ (item) in
//
//                if item.name == category {
//                    isFound = true
//                }
//
//            })
//
//            if isFound == false {
//                let newCategory: CategoryModel?
//                if categories.count == 0 {
//                    newCategory = CategoryModel(name: category, isSelected: true)
//                } else {
//                    newCategory = CategoryModel(name: category, isSelected: false)
//                }
//                categories.append(newCategory!)
//            }
//        }
//
//        viewController?.display(viewModel: .categories(categories))
//        viewController?.display(viewModel: .productsRM(response))
//    }
//
    func presentSales(response: SalesResponse) {

        let sales = response.data

        viewController?.display(viewModel: .sales(sales))
    }
//
//    func presentSalesRM(response: [SalesRM]) {
//        viewController?.display(viewModel: .salesRM(response))
//    }
}
